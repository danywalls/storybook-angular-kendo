/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component } from '@angular/core';
/* eslint-disable import/no-deprecated */
import { Subscription, fromEvent, merge } from 'rxjs';
import { filter } from 'rxjs/operators';
import { KeyEvents } from './../navigation/key-events';
import { NavigationAction } from './../navigation/navigation-action';
import { isDocumentAvailable, guid, Keys } from '@progress/kendo-angular-common';
import { isPresent } from './../util';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import * as i0 from "@angular/core";
import * as i1 from "./../focusable/focus.service";
import * as i2 from "./../navigation/navigation.service";
import * as i3 from "@progress/kendo-angular-l10n";
/**
 * @hidden
 */
export class ListButton {
    constructor(focusService, navigationService, wrapperRef, _zone, localization, cdr) {
        this.focusService = focusService;
        this.navigationService = navigationService;
        this.wrapperRef = wrapperRef;
        this._zone = _zone;
        this.cdr = cdr;
        this._open = false;
        this._disabled = false;
        this._active = false;
        this._popupSettings = { animate: true, popupClass: '' };
        this.listId = guid();
        this._isFocused = false;
        this.subs = new Subscription();
        validatePackage(packageMetadata);
        this.focusService = focusService;
        this.navigationService = navigationService;
        this.wrapper = wrapperRef.nativeElement;
        this.subs.add(localization.changes.subscribe(({ rtl }) => (this.direction = rtl ? 'rtl' : 'ltr')));
        this.subscribeEvents();
    }
    get popupClasses() {
        const popupClasses = ['k-menu-popup'];
        if (this._popupSettings.popupClass) {
            popupClasses.push(this._popupSettings.popupClass);
        }
        return popupClasses.join(' ');
    }
    get openState() {
        return this._open;
    }
    set openState(open) {
        this._open = open;
    }
    /**
     * @hidden
     */
    togglePopupVisibility() {
        if (this._disabled) {
            return;
        }
        this.openState = !this.openState;
        if (!this.openState) {
            this.focusService.focus(-1);
        }
    }
    /**
     * @hidden
     */
    onItemClick(index) {
        this.emitItemClickHandler(index);
        setTimeout(() => this.focusWrapper(), 1);
    }
    ngOnDestroy() {
        this.openState = false;
        clearTimeout(this.focusFirstTimeout);
        clearTimeout(this.blurTimeout);
        this.subs.unsubscribe();
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.subscribeListItemFocusEvent();
        this.subscribeComponentBlurredEvent();
        this.subscribeNavigationEvents();
    }
    subscribeListItemFocusEvent() {
        this.subs.add(this.focusService.onFocus.subscribe(() => {
            this._isFocused = true;
        }));
    }
    subscribeComponentBlurredEvent() {
        this._zone.runOutsideAngular(() => {
            this.subs.add(this.navigationService.tab.pipe(filter(() => this._isFocused)).subscribe(this.handleTab.bind(this)));
            this.subs.add(fromEvent(document, 'click')
                .pipe(filter((event) => !this.wrapperContains(event.target)), filter(() => this._isFocused))
                .subscribe(() => this._zone.run(() => this.blurWrapper())));
        });
    }
    subscribeNavigationEvents() {
        this.subs.add(this.navigationService.navigate.subscribe(this.focusService.focus.bind(this.focusService)));
        this.subs.add(this.navigationService.enterup.subscribe(() => {
            this.enterHandler();
            this.focusWrapper();
        }));
        this.subs.add(this.navigationService.open.subscribe(() => {
            if (!this._open) {
                this.togglePopupVisibility();
                this.focusFirstItem();
            }
            else {
                this.focusWrapper();
            }
        }));
        this.subs.add(merge(this.navigationService.close, this.navigationService.esc).subscribe(() => this.focusWrapper()));
    }
    enterHandler() { } // eslint-disable-line
    /**
     * @hidden
     */
    keyDownHandler(event) {
        this.keyHandler(event);
    }
    /**
     * @hidden
     */
    keyPressHandler(event) {
        this.keyHandler(event, KeyEvents.keypress);
    }
    /**
     * @hidden
     */
    keyUpHandler(event) {
        this.keyHandler(event, KeyEvents.keyup);
    }
    /**
     * @hidden
     */
    keyHandler(event, keyEvent) {
        if (this._disabled) {
            return;
        }
        let focused = this.focusService.focused || 0;
        const eventData = event;
        const action = this.navigationService.process({
            altKey: eventData.altKey,
            current: focused,
            keyCode: eventData.keyCode,
            keyEvent: keyEvent,
            max: this._data ? this._data.length - 1 : 0,
            min: 0
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Tab &&
            (action !== NavigationAction.Enter || (action === NavigationAction.Enter && this._open))) {
            if (event.keyCode === Keys.Space && action === NavigationAction.EnterUp) {
                this._open = false;
            }
            else {
                eventData.preventDefault();
            }
        }
    }
    emitItemClickHandler(index) {
        const dataItem = this._data[index];
        if (this._itemClick) {
            this._itemClick.emit(dataItem);
        }
        if (dataItem && dataItem.click && !dataItem.disabled) {
            dataItem.click(dataItem);
        }
    }
    focusFirstItem() {
        if (this._data && isPresent(this._data[0])) {
            this.focusFirstTimeout = setTimeout(() => this.focusService.focus(0), 1);
        }
    }
    focusWrapper() {
        if (this._open) {
            this.togglePopupVisibility();
            this.focusButton();
        }
    }
    wrapperContains(element) {
        return this.wrapper === element || this.wrapper.contains(element);
    }
    blurWrapper(emit = true) {
        if (this._open) {
            this.togglePopupVisibility();
        }
        this._isFocused = false;
        if (emit) {
            this._blur.emit();
            this.cdr.markForCheck();
        }
    }
    focusButton() {
        if (this.button) {
            this.button.nativeElement.focus();
        }
    }
    handleTab() {
        this.focusButton();
        this.blurWrapper(false);
    }
}
ListButton.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ListButton, deps: [{ token: i1.FocusService }, { token: i2.NavigationService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i3.LocalizationService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ListButton.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ListButton, selector: "ng-component", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ListButton, decorators: [{
            type: Component,
            args: [{
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: i1.FocusService }, { type: i2.NavigationService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i3.LocalizationService }, { type: i0.ChangeDetectorRef }]; } });
